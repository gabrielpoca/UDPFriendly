\documentclass{llncs}
\usepackage{times}
% \usepackage[T1]{fontenc}

% Comentar para not MAC Users
\usepackage[utf8]{inputenc}

\usepackage[portuges]{babel}

\usepackage{a4}
%\usepackage[margin=3cm,nohead]{geometry}
\usepackage{epstopdf}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage{amsmath}

\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
%\renewcommand{\baselinestretch}{1.5}

% Para ter os objectos no sitio que se pretende com o H.
\usepackage{float}

% Indentar automaticamente
%\usepackage{indentfirst}


\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

\lstset{ %
  basicstyle=\footnotesize,           % the size of the fonts that are used for the code
  }


\begin{document}
%\mainmatter
\title{UDP Friendly}

\titlerunning{UDP Friendly}

\author{Gabriel Poça \and Maria Alves \and Tiago Ribeiro}

\authorrunning{Gabriel Poça \and Maria Alves \and Tiago Ribeiro}

\institute{
University of Minho, Department of  Informatics, 4710-057 Braga, Portugal\\
e-mail: \{a56974,a54807,a54752\}@alunos.uminho.pt
}

\date{}
\bibliographystyle{splncs}

\maketitle


%\begin{center}\small{University of Minho, Department of  Informatics, 4710-057 Braga, Portugal\\
%e-mail: \{a56974,a54807,a54752\}@alunos.uminho.pt}\end{center}


\begin{abstract}
Resumo do relatório.
\end{abstract}

% Introdução
\section{Notas Iniciais}
Este documento serve como resumo, intermédio, para acompanhamento do projecto prático de Comunicação por Computadores. São abordadas as metodologias e os conceitos adoptados.

\section{Implementação}
Esta secção trata com maior detalhe a componente da implementação do projecto. Aqui são abordados as diferentes entidades a funcionar em cada aplicação (cliente e servidor), a implementação dos cabeçalhos, etc.

\section{Comunicação}
\subsection{Tipos de Mensagens}

Cada mensagem tranpsorta diferentes elementos de informação, por exemplo, um mensagem \textit{INFO} tem bytes da informação a enviar e um indicador da posição da mesma. Existem três \textbf{elementos de cabeçalho}:


\begin{description}
	\item[Tipo] 	Tipo da mensagem (os diferentes tipos são apresentados a seguir).
	\item[Posição] 	Numero que representa a posição do pacote numa sequência que constitui a informação enviada.
	\item[Data] 	Informação a enviar por pacote.
\end{description}


Diferentes tipos de mensagens preenchem diferentes elementos de informação, mensagens de \textit{ACK} não enviam bytes de informação. Existem os seguintes tipos de mensagem:


\begin{description}
	\item[SYN] Mensagem inicial no establecer da comunicação com o servidor.
	\item[SYN\_ACK] Mensagem de confirmação de SYN.
	\item[INFO] Mensagem que transporta informação sobre o documento a enviar.
	\item[ACK] Mensagem de confirmação da recepção de uma mensagem INFO.
	\item[FIN] Mensagem de final de comunicação.
	\item[FIN\_ACK] Mensagem de confirmação da recepção de FIN.
\end{description}


No processo de comunicação do cliente com o servidor o primeiro apenas comunica com mensagens \textit{SYN}, \textit{INFO} e \textit{FIN} e o outro com as restantes. Mas tal será esclarecido na secção sobre protocolo.


\subsection{Protocolo}
A comunicação pode ser dividida em três componentes: establecer da comunicação, envio da informação e terminar da comunicação. As secções abaixo explicam as mesmas.

\subsubsection{Establecer da comunicação}
A comunicação tem inicio com o envio da mensagem \textit{SYN} pelo client. O servidor recebe a mensagem e responde com \textit{SYN\_ACK}. Da mensagem \textit{SYN\_ACK} o cliente retira informação quanto à porta para a qual deverá continuar a comunicação, tal é necessário uma vez que se trata de aplicação para multiplos servidores, caso contrário não haveria necessidade de mudança de porta. Establecida a comunicação o cliente pode enviar informação e terminar a comunicação.


\textbf{INSERIR GRÁFICO DAS PORTAS}


\subsubsection{Envio da informação}
O \textit{upload} de informação para o servidor é realizado através de mensagens \textit{INFO}. Cada mensagem é constituida por informação (conjunto de bytes a enviar para o servidor) e um indicador da posição da mesma informação numa sequencia que permite reconstituir a informação no servidor.

\subsubsection{Terminar}
A comunicação termina quando o cliente envia a mensagem \textit{FIN}. O servidor deve responder com \textit{FIN\_ACK} procedendo então à descodificação da informação recebida.

\subsection{Controlo de congestão}

Quando a carga oferecida a uma rede é superior à sua capacidade acontece um congestionamento. A soluçao para este problema passa por diminuir a taxa de transmissão de dados.
Existe um protocolo que gere essa taxa bastante bem, o TCP. E uma vez que a sua implementação foi estudada exaustivamente, acreditamos que seja possivel obter bons resultados. Como tal decidimos que o nosso controlo de congestão seguiria o modelo que o TCP utiliza.

Uma das solução para fazer variar a transmissão de dados passa por implementar o mecanismo de janela dinâmica.

\subsubsection{Aumentar o tamanho da janela}

De cada vez que o servidor recebe um pacote, envia uma confirmação para o cliente. À medida que essas confirmações chegarem, caso não haja timeout’s, e assim que o número de confirmações for igual ao tamanho da janela, esta aumentará.
Aumentará para o dobro, caso o tamanho da janela seja inferior ao Threshold, caso contrário será incrementada em uma unidade.

\subsubsection{Diminuir o tamanho da janela}

Quando uma confirmação não chega, ou não chega a tempo ocorre um timeout. 
O cálculo do timeout é baseado numa soma entre a média ponderada do RTT (round trip time) novo (sampleRTT) e o anterior (estimatedRTT) e quatro vezes a média ponderada do desvio padrão anterior e o novo.
As funções a seguir apresentadas correspondem ao cálculo desses três tempo, estimatedRTT, devRTT e timeout:

\lstset{language=Java,caption={Implementação do algortimo de calculo do timeout},label=Timeout}
\begin{lstlisting}
private long estimateRTT(long sampleRTT) {
	long newRTT = (long) ((1 - _alpha) * 
		_estimatedRTT + _alpha * sampleRTT);
		_estimatedRTT = newRTT;
	return _estimatedRTT;
}

private long calculateDevRTT(long sampleRTT) {
	long newdevRTT = (long) ((1 - _beta) * _devRTT + 
		_beta * (Math.abs(sampleRTT - _estimatedRTT)));
	_devRTT = newdevRTT;
	return _devRTT;
}

private void calculateTimeOut(long sampleRTT) {
	_timeout = estimateRTT(sampleRTT) + 4 * calculateDevRTT(sampleRTT);
}    
\end{lstlisting}


%UNCOMMENT se necessário
%De acordo com o ilustrado na Figura~\ref{fig:controller}
%% Exemplo para inserção de uma figura
%\begin{figure}
%\begin{center}
%\includegraphics[scale=0.40]{figura.pdf} 
%\end{center}
%\caption{\label{fig:controller}Architecture of the unified QoS metric fuzzy controller.}
%\end{figure} 


\end{document}
